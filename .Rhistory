library(ggplot2)
library(compositions) # only for ilr
library(viridis)
library(Compositional) # only for helm
## Parameters
alpha_krig = c(0, 0.1, 0.2, 0.4, 0.6, 0.8, 0.9, 1) # values of alpha for kriging
alpha_0 = 0 # for the inverse alpha-IT in the simulation
N <- length(alpha_krig)
## Dimension of the simplex
D = 3
H = helm(D)
## N_samples is the number of observations
N_samples = 500
## N_try is the number of simulations MC
N_try = 10 # change to the number of MC simualations that you want to do (we use with N_try=100 in the paper)
####### START 1 ######
## Run this section if no simulation has been run yet ##
## Choice of the model for the bivariate random field
model <- RMbiwm(nudiag=c(1, 1), c=c(1,0.8,1)) # Whittle-Matérn model
install.packages(pkgs = "C:/documents/RandomFields_3.3.14.tar.gz", type="source", repos=NULL)
install.packages("randomFields")
## Set "path" to your local path and uncomment
# path = ''
# setwd(path)
devtools::install_version("RandomFields", version="3.3")
## Libraries
library(RandomFields)
library(spdep)
library(sf)
library(maptools)
library(classInt)
library(RColorBrewer)
library(stats)
install.packages("maptools")
installed.packages("RandomFields", type= "source")
installed.packages("RandomFields")
install.packages("RandomFields", type= "source")
devtools::install_version("RandomFields", version = "3.3.14")
## Set "path" to your local path and uncomment
# path = ''
# setwd(path)
devtools::install_version("RandomFields", version="3.3")
## Libraries
library(RandomFields)
library(sp)
install.packages("geoR")
install.packages("gstat")
## Choice of the model for the bivariate random field
model <- RMbiwm(nudiag=c(1, 1), c=c(1,0.8,1)) # Whittle-Matérn model
library(gstat)
x <- seq(0, 10, length.out = 100)
y <- seq(0, 10, length.out = 100)
grid <- expand.grid(x = x, y = y)
# Definizione del modello di covarianza (ad esempio, esponenziale)
cov_model <- gstat(formula = ~1, locations = ~x + y, data = grid, model = vgm(psill = 1, model = "Exp", range = 1))
# Stima dei parametri del modello
cov_model_fit <- fit.lmc(cov_model)
x <- seq(0, 10, length.out = 100)
y <- seq(0, 10, length.out = 100)
grid <- expand.grid(x = x, y = y)
# Creazione di dati di esempio (sostituisci con i tuoi dati reali)
set.seed(123)
data <- data.frame(x = runif(100, min = 0, max = 10), y = runif(100, min = 0, max = 10), z = rnorm(100))
# Calcolo del variogramma empirico
variogram <- variogram(z ~ 1, data)
# Calcolo del variogramma empirico
variogram <- variogram(z ~ 1, data)
data <- data.frame(x = runif(100, min = 0, max = 10), y = runif(100, min = 0, max = 10), z = rnorm(100))
# Calcolo del variogramma empirico
variogram <- variogram(z ~ 1, data)
# Calcolo del variogramma empirico
variogram <- variogram(z ~ 1, data= data)
# Creazione di dati di esempio (sostituisci con i tuoi dati reali)
set.seed(123)
dataf <- data.frame(x = runif(100, min = 0, max = 10), y = runif(100, min = 0, max = 10), z = rnorm(100))
# Calcolo del variogramma empirico
variogram <- variogram(object = z ~ 1, data = dataf)
# Calcolo del variogramma empirico
variogram <- variogram(object = dataf$z ~ 1, data = dataf)
# Calcolo del variogramma empirico
variogram <- variogram(dataf$z ~ 1)
# Calcolo del variogramma empirico
variogram <- variogram(z ~ 1, dataf)
library(sp)
data(meuse)
# no trend:
coordinates(meuse) = ~x+y
variogram(log(zinc)~1, meuse)
# residual variogram w.r.t. a linear trend:
variogram(log(zinc)~x+y, meuse)
# directional variogram:
variogram(log(zinc)~x+y, meuse, alpha=c(0,45,90,135))
variogram(log(zinc)~1, meuse, width=90, cutoff=1300)
# GLS residual variogram:
v = variogram(log(zinc)~x+y, meuse)
v.fit = fit.variogram(v, vgm(1, "Sph", 700, 1))
v.fit
set = list(gls=1)
v
g = gstat(NULL, "log-zinc", log(zinc)~x+y, meuse, model=v.fit, set = set)
variogram(g)
View(data)
data(meuse)
View(meuse)
x <- seq(0, 10, length.out = 100)
y <- seq(0, 10, length.out = 100)
grid <- expand.grid(x = x, y = y)
# Creazione di dati di esempio (sostituisci con i tuoi dati reali)
set.seed(123)
dataf <- data.frame(x = runif(100, min = 0, max = 10), y = runif(100, min = 0, max = 10), z = rnorm(100))
View(meuse)
View(dataf)
coordinates(dataf) = ~x+y
# Calcolo del variogramma empirico
variogram <- variogram(z ~ 1, dataf)
data(meuse)
# no trend:
coordinates(meuse) = ~x+y
variogram(log(zinc)~1, meuse)
# residual variogram w.r.t. a linear trend:
variogram(log(zinc)~x+y, meuse)
x <- seq(0, 10, length.out = 100)
y <- seq(0, 10, length.out = 100)
set.seed(123)
dataf <- data.frame(x,y, z = rnorm(100))
coordinates(dataf) = ~x+y
# Calcolo del variogramma empirico
variogram <- variogram(z ~ 1, dataf)
View(variogram)
# Definizione del modello di covarianza basato sul variogramma stimato
cov_model <- fit.variogram(variogram, vgm(1, "Exp", 1))
# Simulazione del campo gaussiano
gaussian_field <- gstat(id = "z", formula = z ~ 1, dummy = TRUE, beta = 0, model = cov_model, nmax = 1, startvals = c(0.5))
model = RMgauss(dim=2, scale=10)
library(RandomFields)
library(Ternary)
library(lattice)
library(wesanderson)
library(latex2exp)
library(RGeostats)
library(ggplot2)
model = RMgauss(dim=2, scale=10)
RFgetModelNames(type="positive definite",
iso="isotropic")
RFgetModelNames()
library(geoR)
help(grf)
data(parana)
pr1 <- grf(100, cov.pars=c(200, 40), borders=parana$borders, mean=500)
points(pr1)
pr1 <- grf(100, grid="reg", cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
pr1 <- grf(100, grid="reg", nx=10, ny=5, cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
pr1 <- grf(100, cov.pars=c(200, 40), borders=parana$borders, mean=500)
points(pr1)
pr1 <- grf(100, grid="reg", cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
pr1 <- grf(100, grid="reg", nx=10, ny=5, cov.pars=c(200, 40), borders=parana$borders)
points(pr1)
grid_locations = expand.grid(x,y)
ggplot(grid_locations, aes(x= X, y=Y)) + geom_point()
x <- y <- seq(1, 100, length.out=100)
grid_locations = expand.grid(x,y)
ggplot(grid_locations, aes(x= X, y=Y)) + geom_point()
x <- y <- seq(1, 100, length.out=100)
grid_locations = expand.grid(x,y)
ggplot(grid_locations, aes(x= X, y=Y))
x <- y <- seq(1, 100, length.out=100)
grid_locations = expand.grid(X=x,Y=y)
ggplot(grid_locations, aes(x= X, y=Y))
ggplot(grid_locations, aes(x= X, y=Y)) + geom_point() + theme_minimal()
coordinates(grid_locations) = ~ X+ Y
model <- RMgauss(var = 1, scale = 10)
simulated_field <- RFsimulate(model, x = x, y = y)
RFoptions(seed = 200)
model <- RMgauss(var = 1, scale = 10)
simulated_field <- RFsimulate(model, x = x, y = y)
View(simulated_field)
model <- RMgauss(var = 1, scale = 10)
simulated_field <- RFsimulate(model, x = x, y = y)
RFoptions(seed= NA)
model <- RMgauss(var = 1, scale = 10)
simulated_field <- RFsimulate(model, x = x, y = y)
# generazione griglia ----
x <- y <- seq(1, 100, length.out=100)
grid_locations = expand.grid(X=x,Y=y)
ggplot(grid_locations, aes(x= X, y=Y)) + geom_point() + theme_minimal()
# così ho griglia fitta 100 * 100
coordinates(grid_locations) = ~ X+ Y    # diventa spatial dataframe
RFoptions(seed= NA)
model <- RMgauss(var = 1, scale = 10)
simulated_field <- RFsimulate(model, x = x, y = y)
# Converti i risultati in un dataframe per ggplot2
sim_df <- data.frame(X = grid_locations$X, Y = grid_locations$Y, Value = as.vector(simulated_field))
View(sim_df)
ggplot(sim_df, aes(x = X, y = Y, fill = Value)) +
geom_tile() +
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = mean(sim_df$Value)) +
labs(title = "Campo Casuale Gaussiano",
x = "X",
y = "Y",
fill = "Valore") +
theme_minimal()
dati <- c(5.5, 6, 7, 6, 7.5, 6, 7.5, 5.5, 7, 6.5)
varianza_campionaria <- var(dati)
mean(dati)
dati2 <- c(7.5, 6, 8.5, 7, 6.5, 8, 7.5, 6.5, 7.5, 6, 8.5, 7)
mean(dati2)
varianza_campionaria2 <- var(dati2)
test_t <- t.test(dati1, dati2)
test_t <- t.test(dati, dati2)
View(test_t)
pesi <- c(25.64, 30.72, 27.88, 26.26, 28.92, 26.90, 24.54, 28.40)
# Calcoliamo la varianza campionaria
varianza_campionaria <- var(pesi)
# Numero di osservazioni
n <- length(pesi)
# Calcoliamo l'intervallo di confidenza al 95% per la varianza
alpha <- 0.05
lower <- ((n - 1) * varianza_campionaria) / qchisq(1 - alpha/2, df = n - 1)
upper <- ((n - 1) * varianza_campionaria) / qchisq(alpha/2, df = n - 1)
# Stampiamo l'intervallo di confidenza
cat("Intervallo di confidenza al 95% per la varianza:", "\n")
cat("[", lower, ", ", upper, "]", "\n")
# Dati forniti
sum_x <- 4310
sum_x_squared <- 1867550
sum_y <- 1143
sum_y_squared <- 136239
sum_xy <- 499115
n <- 25
# Calcoli necessari
mean_x <- sum_x / n
mean_y <- sum_y / n
# Calcolo della varianza di X
var_x <- (sum_x_squared - sum_x^2 / n) / n
# Calcolo della covarianza tra X e Y
cov_xy <- (sum_xy - sum_x * sum_y / n) / n
# Calcolo del coefficiente b1 (pendenza)
b1 <- cov_xy / var_x
# Calcolo del coefficiente b0 (intercetta)
b0 <- mean_y - b1 * mean_x
# Stampiamo i risultati
cat("Coefficiente b0 (intercetta):", b0, "\n")
cat("Coefficiente b1 (pendenza):", b1, "\n")
# Calcolo degli errori standard
residuals <- sum_y_squared - sum_y^2 / n - b0^2 - b1^2 * (sum_x_squared - sum_x^2 / n) / n
se_b0 <- sqrt(residuals * var_x / (n - 2)) / sqrt(sum_x^2 / n)
# Calcolo dell'intervallo di confidenza al 95% per b0
alpha <- 0.05
t_value <- qt(1 - alpha / 2, df = n - 2)
lower_ci <- b0 - t_value * se_b0
upper_ci <- b0 + t_value * se_b0
# Stampiamo l'intervallo di confidenza
cat("Intervallo di confidenza al 95% per b0 (intercetta):", "\n")
cat("[", lower_ci, ", ", upper_ci, "]", "\n")
b0
n
t_value
se_b0
# Calcolo degli errori standard
residuals <- sum_y_squared - sum_y^2 / n - b0^2 - b1^2 * (sum_x_squared - sum_x^2 / n) / n
se_b0 <- sqrt(residuals * var_x / (n - 2)) / sqrt(sum_x^2 / n)
se_b1 <- sqrt(residuals / (n - 2)) / sqrt(sum_x_squared - sum_x^2 / n)
# Calcolo del valore critico della distribuzione t per un intervallo di confidenza del 95%
alpha <- 0.05
t_value <- qt(1 - alpha / 2, df = n - 2)
# Calcolo degli intervalli di confidenza per b0 e b1
ci_lower_b0 <- b0 - t_value * se_b0
ci_upper_b0 <- b0 + t_value * se_b0
# Calcolo della media di Y
mean_y <- sum_y / n
# Calcolo della somma dei residui al quadrato
residual_sum_of_squares <- sum_y_squared - (sum_y^2 / n)
# Calcolo di s^2
s2 <- residual_sum_of_squares / (n - 2)
sqrt(s2)
ss = sqrt(s2)
# Calcolo della varianza residua s^2
y_pred <- b0 + b1 * (1:n)
residuals <- sum_y - y_pred
s2 <- sum(residuals^2)
s2
sqrt(s2)
# Dati forniti
sum_x <- 4310
sum_x_squared <- 1867550
sum_y <- 1143
sum_y_squared <- 136239
sum_xy <- 499115
n <- 25
# Calcolo della media di X e Y
mean_x <- sum_x / n
mean_y <- sum_y / n
# Calcolo della varianza di X
var_x <- (sum_x_squared - sum_x^2 / n) / n
# Calcolo della covarianza tra X e Y
cov_xy <- (sum_xy - sum_x * sum_y / n) / n
# Calcolo del coefficiente di regressione b
b <- cov_xy / var_x
# Calcolo dell'intercetta b0
b0 <- mean_y - b * mean_x
# Calcolo di SST (somma dei quadrati totali)
SST <- sum_y_squared - sum_y^2 / n
# Calcolo di SSR (somma dei quadrati della regressione)
SSR <- b^2 * var_x * n
# Calcolo di R-squared (coefficiente di determinazione)
R_squared <- SSR / SST
# Stampiamo il risultato
cat("Coefficient of determination (R-squared):", R_squared, "\n")
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
library(wfda)
library(Rcpp)
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
matrix_data <- curves
load("curves.Rdata")
load("t_points.Rdata")
load("mean_cov.Rdata")
setwd("C:/Users/Utente/Desktop/Test")
load("curves.Rdata")
load("t_points.Rdata")
load("mean_cov.Rdata")
setwd("C:/Users/Utente/Desktop/Test/wfda")
load("curves.Rdata")
load("t_points.Rdata")
load("mean_cov.Rdata")
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
matrix_data <- curves
View(curves)
matrix_data <- curves[,7:12]
reconst_fcts   <- find_obs_inc(Y = matrix_data)
setwd("C:/Users/Utente/Desktop/WFDA_ALICE")
source('code/functions/weighted-analysis.R')
source('code/functions/generate-data.R')
source('code/functions/weighted-smoothing.R')
source('code/functions/weighted-regression.R')
source('code/functions/unweighted-regression.R')
source('code/functions/reconstruction.R')
source('code/functions/weighted-analysis.R')
source('code/functions/weighted-regression.R')
source('code/functions/weighted-smoothing.R')
source('code/functions/reconstruction.R')
reconst_fcts   <- find_obs_inc(Y = matrix_data)
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
library(wfda)
library(Rcpp)
load("curves.Rdata")
load("t_points.Rdata")
load("mean_cov.Rdata")
setwd("C:/Users/Utente/Desktop/Test/wfda")
load("curves.Rdata")
load("t_points.Rdata")
load("mean_cov.Rdata")
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
matrix_data <- curves
View(curves)
matrix_data <- curves[,7:12]
reconst_fcts   <- find_obs_inc(Y = matrix_data)
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
library(wfda)
library(Rcpp)
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
library(wfda)
library(Rcpp)
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
library(wfda)
library(Rcpp)
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
matrix_data <- curves
View(curves)
matrix_data <- curves[,7:12]
reconst_fcts   <- find_obs_inc(Y = matrix_data)
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
library(wfda)
library(Rcpp)
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
install.packages("../wfda_1.0.tar.gz")
library(wfda)
library(Rcpp)
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
install.packages("../wfda_1.0.tar.gz")
library(wfda)
library(Rcpp)
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
############# Kraus
kraus <- new(ReconstructionBase, "Kraus", matrix_data)
krmean = kraus$mean()
krcov = kraus$cov()
kraus <- kraus$reconstruct(NULL, FALSE, NULL, NULL, NULL, NULL)
######## Extrapolation
extrapolationo <- new(ReconstructionBase, "Extrapolation", matrix_data)
extrapolationo <- extrapolationo$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
# hers
Y_list <- lapply(seq_len(ncol(matrix_data)), function(i) matrix_data[!is.na(matrix_data[,i]),i])
U_list <- lapply(seq_len(ncol(matrix_data)), function(i) t.points[!is.na(matrix_data[,i])])
klal_ <- reconstructKneipLiebl(Ly             = Y_list,
Lu             = U_list,
method         = 'Error>0_AlignYES_CEscores',
K              = NULL,
reconst_fcts   = reconst_fcts,
nRegGrid       = NULL,
maxbins        = NULL,
progrbar       = FALSE)
# results
reconstruct_klal <- klal$Y_reconst_list  #cpp
reconstruct_klal_ <- klal_$Y_reconst_list#R
weights_klal <- klal$W_reconst_list  #cpp
weights_klal_ <- klal_$W_reconst_list#R
View(weights_klal_)
View(weights_klal)
View(reconstruct_klal_)
View(reconstruct_klal)
#installing package
setwd("C:/Users/Utente/Desktop/Test/lastversion")
remove.packages("wfda")
Rcpp::compileAttributes()
devtools::build()
devtools::check()
install.packages("../wfda_1.0.tar.gz")
library(wfda)
library(Rcpp)
reconstruction <- Module("reconstruction", PACKAGE = "wfda")
ReconstructionBase <- reconstruction$ReconstructionBase
##################### KLAl
klal <- new(ReconstructionBase, "KLAl", matrix_data)
klal <- klal$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
############# Kraus
kraus <- new(ReconstructionBase, "Kraus", matrix_data)
krmean = kraus$mean()
krcov = kraus$cov()
kraus <- kraus$reconstruct(NULL, FALSE, NULL, NULL, NULL, NULL)
######## Extrapolation
extrapolationo <- new(ReconstructionBase, "Extrapolation", matrix_data)
extrapolationo <- extrapolationo$reconstruct(NULL, FALSE, t.points, NULL, NULL, NULL)
